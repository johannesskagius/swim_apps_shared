import 'package:flutter/foundation.dart';

/// A data model class that holds all the information for a single
/// 'Off the Block' analysis swim_session.
class StartAnalyze {
  /// A unique identifier for the analysis, typically generated by the backend.
  final String id;

  /// The title of the analysis (e.g., "Morning Starts Practice")
  final String title;

  /// The date when the analysis was performed.
  final DateTime date;

  /// The swimmer's Firestore UID if linked to a profile.
  final String? swimmerId;

  /// The swimmer's display name â€” used when tagging unlinked swimmers.
  final String? swimmerName;

  /// The coach who created or owns this analysis.
  final String coachId;

  /// The club to which the swimmer or coach belongs.
  final String clubId;

  /// Timestamped events during the off-the-block analysis.
  final Map<String, int> markedTimestamps;

  /// Measured start distance (in meters).
  final double startDistance;

  /// Height of the start platform (in meters).
  final double startHeight;

  /// Ai interpretation
  String? aiInterpretation;

  /// Optional physics/jump data calculated from the analysis.
  final Map<String, double>? jumpData;

  /// Metadata: created / updated timestamps.
  final DateTime createdDate;
  final DateTime? updatedDate;

  StartAnalyze({
    required this.id,
    required this.title,
    required this.date,
    required this.coachId,
    required this.clubId,
    required this.markedTimestamps,
    required this.startDistance,
    required this.startHeight,
    required this.createdDate,
    this.updatedDate,
    this.swimmerId,
    this.swimmerName,
    this.jumpData,
    this.aiInterpretation
  });

  /// Creates an instance from a map (e.g., from Firestore or JSON).
  factory StartAnalyze.fromMap(Map<String, dynamic> map, String id) {
    return StartAnalyze(
      id: id,
      title: map['title'] as String,
      date: DateTime.parse(map['date'] as String),
      clubId: map['clubId'] as String,
      coachId: map['coachId'] as String,
      createdDate: DateTime.parse(map['createdDate'] as String),
      updatedDate: map['updatedDate'] != null
          ? DateTime.parse(map['updatedDate'] as String)
          : null,
      swimmerId: map['swimmerId'] as String?,
      swimmerName: map['swimmerName'] as String?,
      markedTimestamps: Map<String, int>.from(map['markedTimestamps'] as Map),
      startDistance: (map['startDistance'] as num).toDouble(),
      startHeight: (map['startHeight'] as num).toDouble(),
      aiInterpretation: map['aiInterpretation'],
      jumpData: map['jumpData'] != null
          ? Map<String, double>.from(map['jumpData'] as Map)
          : null,
    );
  }

  /// Converts the instance to a map for serialization (e.g., Firestore write).
  Map<String, dynamic> toMap() {
    return {
      'title': title,
      'date': date.toIso8601String(),
      'swimmerId': swimmerId,
      'swimmerName': swimmerName,
      'clubId': clubId,
      'coachId': coachId,
      'createdDate': createdDate.toIso8601String(),
      if (updatedDate != null) 'updatedDate': updatedDate!.toIso8601String(),
      'markedTimestamps': markedTimestamps,
      'startDistance': startDistance,
      'startHeight': startHeight,
      'aiInterpretation': aiInterpretation,
      if (jumpData != null) 'jumpData': jumpData,
    };
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is StartAnalyze &&
        other.id == id &&
        other.title == title &&
        other.date == date &&
        other.swimmerId == swimmerId &&
        other.swimmerName == swimmerName &&
        mapEquals(other.markedTimestamps, markedTimestamps) &&
        other.startDistance == startDistance &&
        other.startHeight == startHeight &&
        mapEquals(other.jumpData, jumpData);
  }

  @override
  int get hashCode {
    return id.hashCode ^
        title.hashCode ^
        date.hashCode ^
        swimmerId.hashCode ^
        swimmerName.hashCode ^
        markedTimestamps.hashCode ^
        startDistance.hashCode ^
        startHeight.hashCode ^
        jumpData.hashCode;
  }
}
